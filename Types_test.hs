{-# LANGUAGE TupleSections #-}

import qualified Data.Set as Set
import Data.Set (Set)
import Data.List (inits)
import Data.Monoid
import Test.HUnit
import Types


natTerm n = setAbstr $ args n
  where z = ("x", TVar "a")
        f = ("f", "a" =>= "a")
        args 0 = TNF [] z []
        args n = TNF [] f [args $ n - 1]
        setAbstr (TNF _ h ts) = TNF [f, z] h ts

kTerms = [tnf x, tnf y]
  where x   = ("x", TVar "a")
        y   = ("x₂", TVar "a")
        tnf = \h -> TNF [x, y] h []

-- ((0→0)→0)→0
threeTerms n = map toTNF vars
  where f    = ("F", fromNum 2)
        name = ('x' :) . toLower . (\i -> if i == 1 then "" else show i)
        vars = (, TVar "0") . name <$> [1..n]
        ts x = foldr (\ab tail -> TNF [ab] f [tail])
                     (TNF [last vars] x []) (init vars)
        toTNF = TNF [f] f . pure . ts

-- generate a sequence of \abstr. f (g (f (f (g ... f x))))
-- where f, g are from alph
word :: Abstr -> [Decl] -> Int -> (TNF -> [TNF])
word abstr alph len x = map (setAbstr . run) res
  where
    run foo = appEndo foo x
    setAbstr (TNF _ h ts) = TNF abstr h ts
    toTNF h = TNF [] h . pure
    res     = map mconcat $ sequence $ replicate len $ (Endo . toTNF) <$> alph

-- (0→0)→(0→0)→(0→0)
fgxTerms n = word [f, g, x] [f, g] n (TNF [] ("x", TVar "0") [])
  where
    x = ("x", TVar "0")
    f = ("f",  "0" =>= "0")
    g = ("f₂", "0" =>= "0")


-- takes a threeTerm and replaces each \xi → \fi
-- and generates words in the body
insertFgx :: Int -> [Decl] -> TNF -> [TNF]
insertFgx len fns (TNF [((_:num), _)] _ ts) = tnf
  where tnf     = concat $ ((tailTNF >>=) . word [f] (f : fns)) <$> [0..len]
        f       = ('f':num, fromNum 1)
        toPhi t = TNF [] ("Ф", fromNum 3) [t]
        tailTNF = if null ts
                  then [TNF [] ("x", TVar "0") []]
                  else toPhi <$> insertFgx len (f : fns) (head ts)

-- 3→0→0 or  ((0→0)→0)→0→0→0
-- it is a combination of threeTerms and fgxTerms
phiTerms numOfF numOfPhi =
    if numOfPhi > 0 then toTNF <$> fs else [TNF [phi, x] x []]
  where
    x       = ("x", fromNum 0)
    phi     = ("Ф", fromNum 3)
    toTNF t = TNF [phi, x] phi [t]
    (TNF _ _ [xs]) = head $ threeTerms numOfPhi
    fs = (\i -> reverse $ insertFgx i [] xs) =<< [0..numOfF]


main = runTestTT $ test [
    "no results" ~:
      "There are no terms of this type" ~:
        (termsOfType $ TVar "a") ~?= []
    ,
    "id type a→a" ~:
      "There is a term of this type" ~:
        (termsOfType $ "a" =>= "a") ~?=
        [ TNF [("x", TVar "a")] ("x", TVar "a") [] ]
    ,
    "K combinators a→a→a" ~:
      "There are only \\xy.x and \\xy.y" ~:
        (termsOfType $ "a" =>~ ("a" =>= "a")) ~?=
        kTerms
    ,
    "nat type = (0→0)→0→0" ~:
      "Terms are like x, fx, ffx, fffx, …" ~:
        (\i ->
          (take (i+1) $ termsOfType $ ("a" =>= "a") ~> ("a" =>= "a")) ~?=
          (natTerm <$> [0..i])
        ) 30
    ,
    "type 3 = ((0→0)→0)→0" ~:
      "Terms are like \\F.F (\\x₁.… F(\\xn.xi)…)" ~:
        (\i ->
          (take (sum [1..i]) $ termsOfType (fromNum 3)) ~?=
          (threeTerms =<< [1..i])
        ) 30
    ,
    "type 1→1→0→0" ~:
      "Terms are like \\fgx. f (f (g (f (g (f x) …)" ~:
        (\i ->
          (take (sum $ (2^) <$> [0..i]) $
            termsOfType $ (fromNum 1) ~> (fromNum 1) ~> (fromNum 1)) ~?=
          (fgxTerms =<< [0..i])
        ) 11
    ,
    "type 3→0→0 (Terms are like \\Фx. Ф(.. \\fn. w(f1, .., fn) x) ..))" ~:
      "Correct infinite set is subset of gerenated by the algorithm" ~:
        (\i ->
          (Set.fromList $ take i $ phiTerms 4 =<< [0..i])
          `Set.isSubsetOf`
          (Set.fromList $ take (i*50) $ termsOfType ((fromNum 3) ~> (fromNum 1)))
          ~=? True
        ) 20
    ,
    "type 3→0→0 (Terms are like \\Фx. Ф(.. \\fn. w(f1, .., fn) x) ..))" ~:
      "Infinite set generated by algorithm must be subset of the correct set" ~:
        (\i ->
          (Set.fromList $ take i $ termsOfType ((fromNum 3) ~> (fromNum 1)))
          `Set.isSubsetOf`
          (Set.fromList $ take (i*50) $ phiTerms 4 =<< [0..i])
          ~=? True
        ) 20
  ]
